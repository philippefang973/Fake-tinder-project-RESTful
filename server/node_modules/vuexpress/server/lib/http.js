import { request as httpRequest } from 'http'
import { request as httpsRequest } from 'https'
import zlib from 'zlib'
import url from 'url'
import querystring from 'querystring'
import FormData from 'form-data'

const rhttp = /^https?:\/\//
const rjson = /^application\/json\b/

class HTTPError extends Error {
  constructor(message, status) {
    super(message)
    this.status = status
  }
}

export const rawHttp = function rawHttp(options, callback) {
  if (!rhttp.test(options.url)) {
    throw new Error(`unvalid url: ${options.url}`)
  }

  let urls = url.parse(options.url)
  let formdata = options.formdata
  let timeout = options.timeout
  let data = options.data || {}
  let headers = {}
  let method = 'get'

  if (options.method) {
    method = options.method.toLowerCase()
  }

  if (method === 'get') {
    let d = querystring.stringify(data)
    if (d) {
      urls.path += '?' + d
    }
  }

  if (options.headers) {
    for (let key in options.headers) {
      headers[key.toLowerCase()] = options.headers[key]
    }
  }
  if (method === 'post' && !formdata) {
    headers['content-type'] = headers['content-type'] || 'application/x-www-form-urlencoded'
  }

  if (formdata) {
    formdata = new FormData()
    for (let key in data) {
      let v = data[key]
      if (!v.value) {
        v = {
          value: v
        }
      }
      formdata.append(key, v.value, v.options)
    }
    headers['content-type'] = formdata.getHeaders()['content-type']
    headers['content-length'] = formdata.getLengthSync()
  }


  let req
  let reqOptions = {
    host: urls.hostname,
    port: urls.port,
    path: urls.path,
    method,
    headers,
    timeout
  }
  let timingStart = new Date()

  if (urls.protocol === 'https:') {
    req = httpsRequest(reqOptions)
  }
  else {
    req = httpRequest(reqOptions)
  }

  req.on('error', callback)

  req.on('response', response => {
    response.timing = {
      start: timingStart,
      stop: new Date()
    }
    const status = response.statusCode
    if (status >= 200 && status < 300 || status === 304) {
      const done = body => {
        body = body.toString()
        if (rjson.test(response.headers['content-type'])) {
          let json
          try {
            json = JSON.parse(body)
          }
          catch (e) {
            callback(new Error('unvalid json'))
            return
          }
          callback(null, json, response)
        }
        else {
          callback(null, body, response)
        }
      }
      let buffers = []
      response.on('data', chunk => {
        buffers.push(chunk)
      })
      response.on('end', () => {
        let body = Buffer.concat(buffers)
        if (response.headers['content-encoding'] === 'gzip') {
          zlib.gunzip(body, (err, decode) => {
            if (err) {
              callback(err)
            }
            else {
              delete response.headers['content-encoding']
              done(decode)
            }
          })
        }
        else {
          done(body)
        }
      })
    }
    else {
      callback(new HTTPError(response.statusMessage, status))
    }
  })


  if (formdata) {
    formdata.pipe(req)
  }
  else if (method !== 'get') {
    req.write(rjson.test(headers['content-type']) ? JSON.stringify(data) : querystring.stringify(data))
  }

  req.end()

  return req

}

export default function http(options, callback) {
  let thenable = false
  let then = function (onFulfilled, onRejected) {
    let resolve, reject
    thenable = true
    then = function (err, data) {
      if (err) {
        if (onRejected) {
          onRejected(err)
          resolve()
        }
        else {
          reject(err)
        }
      }
      else {
        if (onFulfilled) {
          resolve(onFulfilled(data))
        }
        else {
          resolve(data)
        }
      }
    }
    /* eslint promise/param-names: 0 */
    let promise = new Promise(function (r1, r2) {
      resolve = r1
      reject = r2
    })
    promise.abort = function () {
      req.abort();
    }
    return promise
  }
  let req = rawHttp(options, function () {
    if (thenable) {
      then.apply(null, arguments)
    }
    else {
      callback && callback.apply(null, arguments)
    }
  })
  req.then = then
  return req
}
