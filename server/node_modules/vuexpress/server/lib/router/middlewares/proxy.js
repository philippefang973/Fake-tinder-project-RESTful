import os from 'os'
import util from 'util'
import http from '../../http'

const rCaptureGroup = /\$(\d+)/g

function functionalize(target, handler) {
  if (typeof target === 'function') {
    return target
  }
  else {
    return function (...args) {
      return handler ? handler.call(this, target, ...args) : target
    }
  }
}

function sendProxy(route, request, callback) {
  let { target, prefilter, convert } = route.proxy

  http({
    url: target(...route.path.exec(request.url)),
    data: prefilter ? prefilter(request.data) : request.data,
    headers: request.headers,
    method: route.method === 'all' ? request.method : route.method,
    formdata: route.formdata
  }, (err, result, response) => {
    if (err) {
      callback(err)
    }
    else {
      if (convert) {
        result = convert(result)
      }
      callback(null, result, response)
    }
  })
}

export default function (route, routeSet) {
  let proxy = route.proxy
  if (proxy) {
    if (!proxy.target) {
      throw new Error(`unvalid proxy config for route(${route.path}): ${util.inspect(proxy)}`)
    }
    if (typeof proxy === 'string') {
      proxy = {
        target: proxy
      }
    }
    proxy.target = functionalize(proxy.target, function (target, ...args) {
      return target.replace(rCaptureGroup, (s, i) => i < args.length ? args[i] : s)
    })
    route.proxy = proxy
  }

  function quickProxy(options, callback) {
    let { path, method } = options

    for (let route of routeSet) {
      if ((r.method === 'all' || r.method === method.toLowerCase()) && r.path.test(path)) {
        return sendProxy(route, options, callback)
      }
    }

    throw new Error(`no proxy found by ${path}#${method}`)
  }

  return function (req, res, next) {
    this.httpProxy = quickProxy

    if (!proxy) {
      next()
      return
    }

    let headers = Object.assign({}, req.headers)
    delete headers['host']
    delete headers['referer']
    delete headers['user-agent']

    let data = Object.assign({}, req.method === 'GET' ? req.query : req.body)
    if (route.formdata) {
      for (let file of req.files) {
        data[file.fieldname] = {
          value: file.buffer,
          options: {
            filename: file.originalname,
            contentType: file.mimetype,
            knownLength: file.size
          }
        }
      }
    }

    sendProxy(route, {
      url: req.url,
      method: req.method,
      headers,
      data
    }, (err, result, response) => {
      if (err) {
        next(err)
      }
      else {
        res.status(response.statusCode)
        res.set(response.headers)
        res.send(result)
      }
    })

  }

}
