import test from 'ava'
import sinon from 'sinon'
import { createServer, ClientRequest } from 'http'
import http from '../lib/http'

let server

test.beforeEach(async t => {
  server = createServer((req, res) => {
    server.emit(req.url.replace(/(\?.*)/, ''), req, res)
  })
  await new Promise((resolve, reject) => {
    server.listen(0, 'localhost', (err) => {
      if (err) {
        reject(err)
      }
      else {
        server.url = `http://localhost:${server.address().port}`
        resolve()
      }
    })
  })
})

test.afterEach.always(t => {
  server.close()
})

test.serial('callback', async t => {
  t.plan(6)

  server.on('/api/1', (req, res) => {
    res.end('ok')
  })
  server.on('/api/2', (req, res) => {
    res.writeHead(404)
    res.end('ok')
  })

  await new Promise((resolve, reject) => {
    let req = http({
      url: `${server.url}/api/1`
    }, function () {
      t.pass()
      t.is(arguments[0], null)
      t.is(arguments[1], 'ok')
      resolve()
    })
  })
  await new Promise((resolve, reject) => {
    let req = http({
      url: `${server.url}/api/2`
    }, function () {
      t.pass()
      t.true(arguments[0] instanceof Error)
      t.is(arguments[1], undefined)
      resolve()
    })
  })
})

test.serial('promise', async t => {
  t.plan(6)

  server.on('/api/1', (req, res) => {
    res.end()
  })

  let spyCallback = sinon.spy()
  let spyResolve = sinon.spy()
  let spyReject = sinon.spy()
  let req = http({
    url: `${server.url}/api/1`
  }, spyCallback)

  t.true(req instanceof ClientRequest)
  t.false(req instanceof Promise)
  req = req.then(spyResolve, spyReject)
  t.true(req instanceof Promise)
  await req
  t.false(spyCallback.called)
  t.true(spyResolve.called)
  t.false(spyReject.called)
})

test.serial('GET is used default', t => {
  const req1 = http({
    url: `${server.url}/api/1`,
    method: 'get'
  })
  t.is(req1.method, 'GET')
  t.is(req1.path, '/api/1')

  const req2 = http({
    url: `${server.url}/api/2`
  })
  t.is(req2.method, 'GET')
  t.is(req2.path, '/api/2')
})

test.serial('POST is used application/x-www-form-urlencoded default', async t => {
  t.plan(2)

  server.on('/api/1', (req, res) => {
    t.is(req.method, 'POST')
    t.is(req.headers['content-type'], 'application/x-www-form-urlencoded')
    res.end()
  })

  await http({
    url: `${server.url}/api/1`,
    method: 'post'
  }).then()
})

test.serial('custom headers', async t => {
  t.plan(2)

  server.on('/api/1', (req, res) => {
    t.is(req.headers['content-type'], 'application/json')
    t.is(req.headers['x-requested-with'], 'XMLHttpRequest')
    res.end()
  })

  await http({
    url: `${server.url}/api/1`,
    method: 'post',
    headers: {
      'content-type': 'application/json',
      'x-requested-with': 'XMLHttpRequest'
    }
  }).then()
})

test.serial('send data', async t => {
  t.plan(3)

  server.on('/api/1', (req, res) => {
    t.is(req.url, '/api/1?foo=bar')
    res.end()
  })
  server.on('/api/2', (req, res) => {
    t.is(req.url, '/api/2')
    req.on('data', chunk => {
      t.is(chunk.toString(), 'foo=bar')
    })
    res.end()
  })

  await http({
    url: `${server.url}/api/1`,
    method: 'get',
    data: {
      foo: 'bar'
    }
  }).then()
  await http({
    url: `${server.url}/api/2`,
    method: 'post',
    data: {
      foo: 'bar'
    }
  }).then()

})

test.serial('application/json', async t => {
  t.plan(2)

  server.on('/api/1', (req, res) => {
    t.is(req.url, '/api/1')
    req.on('data', chunk => {
      try {
        chunk = JSON.parse(chunk)
      }
      catch (e) {
        return
      }
      t.deepEqual(chunk, {foo: 'bar'})
    })
    res.end()
  })

  await http({
    url: `${server.url}/api/1`,
    method: 'post',
    headers: {
      'content-type': 'application/json'
    },
    data: {
      foo: 'bar'
    }
  }).then()
})

test.serial('formdata', async t => {
  t.plan(2)

  server.on('/api/1', (req, res) => {
    let result = ''
    req.on('data', chunk => {
      result += chunk.toString()
    })
    req.on('end', () => {
      t.regex(result, /Content-Disposition: form-data;/)
      t.regex(result, /form-data; name="foo"/)
    })
    res.end()
  })

  await http({
    url: `${server.url}/api/1`,
    method: 'post',
    data: {
      foo: 'bar'
    },
    formdata: true
  }).then()
})
