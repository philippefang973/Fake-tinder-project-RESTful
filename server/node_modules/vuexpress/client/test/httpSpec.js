import 'jasmine-ajax'
import http, { rawHttp, mergeOptions } from '../lib/http'

describe('rawHttp', () => {

  beforeEach(() => {
    jasmine.Ajax.install()
  })

  afterEach(() => {
    jasmine.Ajax.uninstall()
  })

  it('url', () => {
    rawHttp({
      url: '/api/1'
    })
    expect(jasmine.Ajax.requests.mostRecent().url).toBe('/api/1')
  })

  it('method', () => {
    rawHttp({
      url: '/api/1',
      method: 'GET'
    })
    expect(jasmine.Ajax.requests.mostRecent().url).toBe('/api/1')
    expect(jasmine.Ajax.requests.mostRecent().method).toBe('get')

    rawHttp({
      url: '/api/2',
      method: 'post'
    })
    expect(jasmine.Ajax.requests.mostRecent().url).toBe('/api/2')
    expect(jasmine.Ajax.requests.mostRecent().method).toBe('post')

    rawHttp({
      url: '/api/3'
    })
    expect(jasmine.Ajax.requests.mostRecent().url).toBe('/api/3')
    expect(jasmine.Ajax.requests.mostRecent().method).toBe('get')
  })

  it('data when get', () => {
    rawHttp({
      url: '/api/1',
      method: 'get',
      data: { k: 'v' }
    })
    expect(jasmine.Ajax.requests.mostRecent().url).toBe('/api/1?k=v')
    expect(jasmine.Ajax.requests.mostRecent().params).toBe('k=v')
  })

  it('data when post', () => {
    rawHttp({
      url: '/api/1',
      method: 'post',
      data: { k: 'v' }
    })
    expect(jasmine.Ajax.requests.mostRecent().url).toBe('/api/1')
    expect(jasmine.Ajax.requests.mostRecent().params).toBe('k=v')
  })

  it('headers', () => {
    rawHttp({
      url: '/api/1',
      method: 'get'
    })
    expect(jasmine.Ajax.requests.mostRecent().url).toBe('/api/1')
    expect(jasmine.Ajax.requests.mostRecent().requestHeaders).toEqual({})

    rawHttp({
      url: '/api/2',
      method: 'post'
    })
    expect(jasmine.Ajax.requests.mostRecent().url).toBe('/api/2')
    expect(jasmine.Ajax.requests.mostRecent().requestHeaders).toEqual({
      'content-type': 'application/x-www-form-urlencoded'
    })

    rawHttp({
      url: '/api/3',
      method: 'post',
      headers: {
        'accept': 'text/plain'
      }
    })
    expect(jasmine.Ajax.requests.mostRecent().url).toBe('/api/3')
    expect(jasmine.Ajax.requests.mostRecent().requestHeaders).toEqual({
      'content-type': 'application/x-www-form-urlencoded',
      'accept': 'text/plain'
    })
  })

  it('callback with error', () => {
    const spy1 = jasmine.createSpy('ajax callback')
    rawHttp({
      url: '/api/1'
    }, spy1)
    expect(spy1).not.toHaveBeenCalled()
    jasmine.Ajax.requests.mostRecent().respondWith({
      status: 404,
      statusText: 'not found'
    })
    expect(spy1).toHaveBeenCalledWith(jasmine.any(Error))
    expect(spy1.calls.mostRecent().args[0].code).toBe(404)
    expect(spy1.calls.mostRecent().args[0].message).toBe('not found')

    const spy2 = jasmine.createSpy('ajax callback')
    rawHttp({
      url: '/api/1'
    }, spy2)
    expect(spy2).not.toHaveBeenCalled()
    jasmine.Ajax.requests.mostRecent().responseError()
    expect(spy2).toHaveBeenCalledWith(jasmine.any(Error))
    expect(spy2.calls.mostRecent().args[0].code).toBe(0)
    expect(spy2.calls.mostRecent().args[0].message).toBe('error')
  })

  it('callback with json', () => {
    const spy = jasmine.createSpy('ajax callback')
    rawHttp({
      url: '/api/1'
    }, spy)
    expect(spy).not.toHaveBeenCalled()
    jasmine.Ajax.requests.mostRecent().respondWith({
      status: 200,
      contentType: 'plain/text',
      responseText: 'ok'
    })
    expect(spy).toHaveBeenCalledWith(null, 'ok')
  })

  it('callback with valid json', () => {
    const spy1 = jasmine.createSpy('ajax callback')
    rawHttp({
      url: '/api/1'
    }, spy1)
    jasmine.Ajax.requests.mostRecent().respondWith({
      status: 200,
      contentType: 'application/json',
      responseText: '{"k": "v"}'
    })
    expect(spy1).toHaveBeenCalledWith(null, {k: 'v'})

    const spy2 = jasmine.createSpy('ajax callback')
    rawHttp({
      url: '/api/3'
    }, spy2)
    jasmine.Ajax.requests.mostRecent().respondWith({
      status: 200,
      contentType: 'application/json',
      responseText: '<html></html>'
    })
    expect(spy2).toHaveBeenCalledWith(jasmine.any(Error))
    expect(spy2.calls.mostRecent().args[0].code).toBe(0)
    expect(spy2.calls.mostRecent().args[0].message).toBe('unvalid json')
  })

  it('timeout', () => {
    jasmine.clock().install()
    const spy = jasmine.createSpy('ajax callback')
    rawHttp({
      url: '/api/1',
      timeout: 3000
    }, spy)
    expect(spy).not.toHaveBeenCalled()
    jasmine.Ajax.requests.mostRecent().responseTimeout()
    expect(spy).toHaveBeenCalledWith(jasmine.any(Error))
    expect(spy.calls.mostRecent().args[0].code).toBe(0)
    expect(spy.calls.mostRecent().args[0].message).toBe('timeout')
    jasmine.clock().uninstall()
  })

  it('abort', () => {
    const spy = jasmine.createSpy('ajax callback')
    const res = rawHttp({
      url: '/api/1'
    }, spy)
    expect(jasmine.Ajax.requests.mostRecent().url).toBe('/api/1')
    expect(spy).not.toHaveBeenCalled()
    expect(res.abort).toEqual(jasmine.any(Function))
    res.abort()
    expect(spy).toHaveBeenCalledWith(jasmine.any(Error))
    expect(spy.calls.mostRecent().args[0].code).toBe(0)
    expect(spy.calls.mostRecent().args[0].message).toBe('canceled')
  })

})

describe('mergeOptions', () => {

  it('normal merge', () => {
    let a = {
      foo: 'bar'
    }
    let b = {
      qux: 'quxx'
    }
    let c = mergeOptions(a, b)
    expect(a).toEqual({
      foo: 'bar'
    })
    expect(b).toEqual({
      qux: 'quxx'
    })
    expect(c).toEqual({
      foo: 'bar',
      qux: 'quxx'
    })
  })

  it('deep merge', () => {
    let a = {
      foo: {
        bar: 'barz'
      },
      bar: ['barz']
    }
    let b = {
      foo: {
        qux: 'quxx'
      },
      bar: ['qux', 'quxx']
    }
    let c = mergeOptions(a, b)
    expect(c).toEqual({
      foo: {
        bar: 'barz',
        qux: 'quxx'
      },
      bar: ['qux', 'quxx']
    })
  })

  it('url merge', () => {
    let a = {
      url: '/api/'
    }
    let b = {
      url: 'foo'
    }
    let c = {
      url: '/bar'
    }
    let d = {
      url: 'http://qux'
    }
    expect(mergeOptions(a, b)).toEqual({ url: '/api/foo' })
    expect(mergeOptions(a, c)).toEqual({ url: '/bar' })
    expect(mergeOptions(a, d)).toEqual({ url: 'http://qux' })
  })

})

describe('http', () => {

  it('callback', () => {
    const spyCallback = jasmine.createSpy('ajax callback')
    const res = http({
      url: '/api/1'
    }, spyCallback)

    expect(spyCallback).not.toHaveBeenCalled()

    res.abort()

    expect(spyCallback).toHaveBeenCalled()
  })

  it('promise', () => {
    const spyCallback = jasmine.createSpy('ajax callback')
    const spyResolve = jasmine.createSpy('ajax resolve')
    const spyReject = jasmine.createSpy('ajax reject')
    const res = http({
      url: '/api/1'
    }, spyCallback)

    expect(res).toEqual(jasmine.any(XMLHttpRequest))
    expect(res.then).toEqual(jasmine.any(Function))
    expect(res.reject).toBeUndefined()
    expect(res.catch).toBeUndefined()

    const res2 = res.then(spyResolve, spyReject)

    expect(res2).toEqual(jasmine.any(Promise))
    expect(res2.abort).toEqual(jasmine.any(Function))
    expect(spyCallback).not.toHaveBeenCalled()
    expect(spyResolve).not.toHaveBeenCalled()
    expect(spyReject).not.toHaveBeenCalled()

    res2.abort()

    expect(spyCallback).not.toHaveBeenCalled()
    expect(spyResolve).not.toHaveBeenCalled()
    expect(spyReject).toHaveBeenCalled()
  })

})
