import extend from '../utils/extend'

const rjson = /^application\/json\b/
const rroot = /^\/|http:/

class AjaxError extends Error {
  constructor(code = 0, message = 'error') {
    super(message)
    this.code = code
  }
}

export const rawHttp = function rawHttp(options, callback) {
  let url = options.url
  let formdata = options.formdata
  let timeout = options.timeout
  let method = 'get'
  let headers = {}
  let data

  if (!url) {
    callback(new Error('url is required'))
    return
  }

  if (options.method) {
    method = options.method.toLowerCase()
  }

  if (options.headers) {
    for (let key in options.headers) {
      headers[key.toLowerCase()] = options.headers[key]
    }
  }
  if (method === 'post' && !formdata) {
    headers['content-type'] = headers['content-type'] || 'application/x-www-form-urlencoded'
  }

  if (options.data) {
    if (formdata) {
      data = new FormData()
      for (let key in options.data) {
        data.append(key, options.data[key])
      }
    }
    else if (rjson.test(headers['content-type'])) {
      data = JSON.stringify(options.data)
    }
    else {
      data = Object.keys(options.data).map(k => `${k}=${encodeURIComponent(options.data[k])}` ).join('&')
    }
  }

  if (method === 'get' && data) {
    url += '?' + data
  }

  let xhr = new XMLHttpRequest()
  xhr.open(method, url)
  for (let key in headers) {
    xhr.setRequestHeader(key, headers[key])
  }
  xhr.timeout = timeout
  xhr.onabort = function () { callback(new AjaxError(0, 'canceled')) }
  xhr.onerror = function () { callback(new AjaxError(0, 'error')) }
  xhr.ontimeout = function () { callback(new AjaxError(0, 'timeout')) }
  xhr.onload = function() {
    let status = xhr.status
    if (status >= 200 && status < 300 || status === 304) {
      if (rjson.test(xhr.getResponseHeader('content-type'))) {
        let result
        try {
          result = JSON.parse(xhr.responseText)
        }
        catch (e) {
          callback(new AjaxError(0, 'unvalid json'))
          return
        }
        callback(null, result)
      }
      else {
        callback(null, xhr.responseText)
      }
    }
    else {
      callback(new AjaxError(status, xhr.statusText))
    }
  }
  xhr.send(data)
  return xhr
}

export const mergeOptions = function mergeOptions(parent, child) {
  if (parent.url && child.url && !rroot.test(child.url)) {
    child.url = parent.url + child.url
  }
  return extend({}, parent, child)
}

export default function http(options, callback) {
  let thenable = false
  let then = function (onFulfilled, onRejected) {
    let resolve, reject
    thenable = true
    then = function (err, data) {
      if (err) {
        if (onRejected) {
          onRejected(err)
          resolve()
        }
        else {
          reject(err)
        }
      }
      else {
        if (onFulfilled) {
          resolve(onFulfilled(data))
        }
        else {
          resolve(data)
        }
      }
    }
    /* eslint promise/param-names: 0 */
    let promise = new Promise(function (r1, r2) {
      resolve = r1
      reject = r2
    })
    promise.abort = function () {
      xhr.abort();
    }
    return promise
  }
  let xhr = rawHttp(mergeOptions(http.settings, options), function () {
    if (thenable) {
      then.apply(null, arguments)
    }
    else {
      callback && callback.apply(null, arguments)
    }
  })
  xhr.then = then
  return xhr
}

http.settings = {}

http.setup = function (options) {
  extend(this.settings, options)
}
